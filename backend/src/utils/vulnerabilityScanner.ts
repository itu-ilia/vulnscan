import { 
  ScanResults, 
  Vulnerability, 
  ScanMethod, 
  Port, 
  Statistics, 
  PortDetails,
  FlowStep,
  LogEntry,
  StepStatus,
  LogType
} from '../types/scan';
import { mockPortScan } from './portScanner';

interface VulnerablePort extends PortDetails {
  vulnerabilities: Vulnerability[];
}

interface VulnerabilityCount {
  critical: number;
  high: number;
  medium: number;
  low: number;
}

interface ExtendedStatistics extends Statistics {
  severityDistribution: VulnerabilityCount;
  serviceDistribution: Record<string, number>;
  protocolDistribution: Record<string, number>;
  portStateDistribution: Record<string, number>;
}

const vulnerabilityTemplates: Record<string, Vulnerability[]> = {
  http: [
    {
      id: 'CVE-2021-44228',
      severity: 'critical',
      title: 'Log4j Remote Code Execution',
      description: 'A critical vulnerability in Log4j allows remote attackers to execute arbitrary code.',
      recommendation: 'Update Log4j to version 2.15.0 or later',
      references: ['https://nvd.nist.gov/vuln/detail/CVE-2021-44228'],
      attackVector: 'Network',
      impact: {
        confidentiality: 'Critical',
        integrity: 'Critical',
        availability: 'Critical'
      },
      bestPractices: [
        'Update Log4j immediately',
        'Implement WAF rules',
        'Monitor for exploitation attempts',
        'Implement network segmentation'
      ]
    },
    {
      id: 'CVE-2021-23017',
      severity: 'high',
      title: 'Nginx HTTP Request Smuggling',
      description: 'A vulnerability in nginx allows attackers to bypass security controls via HTTP request smuggling.',
      recommendation: 'Upgrade to nginx 1.20.0 or later',
      references: ['https://nvd.nist.gov/vuln/detail/CVE-2021-23017'],
      attackVector: 'Network',
      impact: {
        confidentiality: 'High',
        integrity: 'High',
        availability: 'Medium'
      },
      bestPractices: [
        'Use HTTPS',
        'Implement proper request size limits',
        'Configure security headers',
        'Regular security audits'
      ]
    }
  ],
  ssh: [
    {
      id: 'CVE-2020-14145',
      severity: 'medium',
      title: 'OpenSSH Client Information Disclosure',
      description: 'The client side in OpenSSH allows remote servers to trigger information disclosure.',
      recommendation: 'Upgrade to OpenSSH 8.4 or later',
      references: ['https://nvd.nist.gov/vuln/detail/CVE-2020-14145'],
      attackVector: 'Network',
      impact: {
        confidentiality: 'Medium',
        integrity: 'Low',
        availability: 'None'
      },
      bestPractices: [
        'Use key-based authentication',
        'Disable root SSH login',
        'Use strong SSH protocol version 2',
        'Implement fail2ban'
      ]
    }
  ],
  mysql: [
    {
      id: 'CVE-2021-2154',
      severity: 'critical',
      title: 'MySQL Remote Code Execution',
      description: 'A critical vulnerability in MySQL allows remote attackers to execute arbitrary code.',
      recommendation: 'Upgrade to MySQL 5.7.34 or later',
      references: ['https://nvd.nist.gov/vuln/detail/CVE-2021-2154'],
      attackVector: 'Network',
      impact: {
        confidentiality: 'Critical',
        integrity: 'Critical',
        availability: 'Critical'
      },
      bestPractices: [
        'Restrict remote access',
        'Use strong authentication',
        'Regular updates',
        'Network segmentation'
      ]
    }
  ],
  mongodb: [
    {
      id: 'CVE-2021-20329',
      severity: 'high',
      title: 'MongoDB Privilege Escalation',
      description: 'A vulnerability in MongoDB allows attackers to escalate privileges.',
      recommendation: 'Upgrade to MongoDB 4.4.4 or later',
      references: ['https://nvd.nist.gov/vuln/detail/CVE-2021-20329'],
      attackVector: 'Network',
      impact: {
        confidentiality: 'High',
        integrity: 'High',
        availability: 'Medium'
      },
      bestPractices: [
        'Enable authentication',
        'Use role-based access control',
        'Encrypt data at rest',
        'Regular security audits'
      ]
    }
  ]
};

function getRandomVulnerabilities(service: string, version: string): Vulnerability[] {
  const serviceVulns = vulnerabilityTemplates[service] || [];
  const result: Vulnerability[] = [];
  
  // Randomly select vulnerabilities based on service and version
  serviceVulns.forEach(vuln => {
    // Higher chance of vulnerability for older versions
    const isOldVersion = version.includes('1.') || version.includes('2.') || 
                        version.includes('3.') || version.includes('4.');
    const vulnChance = isOldVersion ? 0.8 : 0.3;
    
    if (Math.random() < vulnChance) {
      result.push({
        ...vuln,
        // Add some randomization to the vulnerability details
        description: `${vuln.description} Version ${version} is affected.`,
        recommendation: `${vuln.recommendation}. Current version: ${version}`
      });
    }
  });
  
  return result;
}

function calculateStatistics(ports: VulnerablePort[]): ExtendedStatistics {
  const vulnCounts: VulnerabilityCount = {
    critical: 0,
    high: 0,
    medium: 0,
    low: 0
  };
  
  const protocolDist: Record<string, number> = {};
  const serviceDist: Record<string, number> = {};
  const stateDist: Record<string, number> = {};
  
  let totalIssues = 0;
  
  ports.forEach(port => {
    // Count vulnerabilities by severity
    port.vulnerabilities?.forEach(vuln => {
      vulnCounts[vuln.severity as keyof VulnerabilityCount]++;
      totalIssues++;
    });
    
    // Count protocols, services, and states
    protocolDist[port.protocol] = (protocolDist[port.protocol] || 0) + 1;
    serviceDist[port.service] = (serviceDist[port.service] || 0) + 1;
    stateDist[port.state] = (stateDist[port.state] || 0) + 1;
  });
  
  return {
    totalIssues,
    criticalIssues: vulnCounts.critical,
    highRiskIssues: vulnCounts.high,
    mediumRiskIssues: vulnCounts.medium,
    lowRiskIssues: vulnCounts.low,
    severityDistribution: vulnCounts,
    protocolDistribution: protocolDist,
    serviceDistribution: serviceDist,
    portStateDistribution: stateDist,
    stateDistribution: stateDist
  };
}

export async function mockFindVulnerabilities(target: string, method: ScanMethod): Promise<ScanResults> {
  // Simulate analysis delay based on method
  const delay = method === 'slow' ? 5000 : method === 'normal' ? 2000 : 1000;
  await new Promise(resolve => setTimeout(resolve, delay));

  // Get open ports from port scanner
  const ports = await mockPortScan(target, method);
  
  // Add vulnerabilities to each port
  const portsWithVulns: VulnerablePort[] = ports.map(port => ({
    ...port,
    vulnerabilities: getRandomVulnerabilities(port.service, port.version)
  }));

  // Calculate statistics
  const stats = calculateStatistics(portsWithVulns);
  
  // Generate summary
  const summary = {
    totalVulnerabilities: stats.totalIssues,
    criticalVulnerabilities: stats.criticalIssues,
    highRiskVulnerabilities: stats.highRiskIssues,
    mediumRiskVulnerabilities: stats.mediumRiskIssues,
    lowRiskVulnerabilities: stats.lowRiskIssues,
    openPorts: portsWithVulns.filter(p => p.state === 'open').length,
    filteredPorts: portsWithVulns.filter(p => p.state === 'filtered').length,
    closedPorts: portsWithVulns.filter(p => p.state === 'closed').length,
    uniqueServices: Object.keys(stats.serviceDistribution).length,
    protocols: Object.keys(stats.protocolDistribution),
    topVulnerableServices: Object.entries(stats.serviceDistribution)
      .map(([service, count]) => ({
        service,
        vulnerabilityCount: portsWithVulns
          .filter(p => p.service === service)
          .reduce((sum, p) => sum + (p.vulnerabilities?.length || 0), 0),
        highestSeverity: portsWithVulns
          .filter(p => p.service === service)
          .flatMap(p => p.vulnerabilities || [])
          .reduce((highest: 'low' | 'medium' | 'high' | 'critical', vuln) => {
            const severityOrder = { critical: 4, high: 3, medium: 2, low: 1 };
            return severityOrder[vuln.severity] > severityOrder[highest] ? vuln.severity : highest;
          }, 'low')
      }))
      .filter(s => s.vulnerabilityCount > 0)
      .sort((a, b) => b.vulnerabilityCount - a.vulnerabilityCount)
  };

  const now = new Date();
  const startTime = new Date(now.getTime() - delay);
  const step1End = new Date(now.getTime() - delay * 0.8);
  const step2End = new Date(now.getTime() - delay * 0.6);
  const step3End = new Date(now.getTime() - delay * 0.4);
  const step4End = new Date(now.getTime() - delay * 0.2);

  const steps: FlowStep[] = [
    { name: 'Initialize', status: 'completed' as StepStatus, progress: 100, startTime, endTime: step1End },
    { name: 'Port Discovery', status: 'completed' as StepStatus, progress: 100, startTime: step1End, endTime: step2End },
    { name: 'Service Detection', status: 'completed' as StepStatus, progress: 100, startTime: step2End, endTime: step3End },
    { name: 'Vulnerability Analysis', status: 'completed' as StepStatus, progress: 100, startTime: step3End, endTime: step4End },
    { name: 'Report Generation', status: 'completed' as StepStatus, progress: 100, startTime: step4End, endTime: now }
  ];

  const logs: LogEntry[] = [
    { timestamp: startTime, type: 'info' as LogType, message: 'Scan initialized', node: 'scanner', action: 'initialize' },
    { timestamp: step2End, type: 'info' as LogType, message: 'Port discovery completed', node: 'scanner', action: 'port_discovery' },
    { timestamp: step3End, type: 'info' as LogType, message: 'Service detection completed', node: 'scanner', action: 'service_detection' },
    { timestamp: step3End, type: 'info' as LogType, message: 'Vulnerability analysis started', node: 'scanner', action: 'vulnerability_analysis' },
    { timestamp: now, type: 'info' as LogType, message: 'Report generation completed', node: 'scanner', action: 'report_generation' }
  ];

  return {
    id: Math.random().toString(36).substring(7),
    target,
    method,
    status: 'completed',
    startTime,
    endTime: now,
    scanDuration: delay / 1000,
    openPorts: portsWithVulns,
    totalPorts: 1000,
    statistics: stats,
    summary,
    configuration: {
      scannerVersion: '1.0.0',
      scannerType: 'VulnScan',
      customCommands: []
    },
    steps,
    logs
  };
} 